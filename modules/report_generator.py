"""
Report Generator Module

Generates comprehensive Markdown and formatted reports from analysis results.
Includes executive summaries, optimization plans, and actionable recommendations.
"""

import pandas as pd
from typing import Dict, List, Any, Optional
from datetime import datetime


def generate_markdown_report(
    results: pd.DataFrame,
    optimization_reports: Dict[str, Dict],
    meta_df: Optional[pd.DataFrame] = None,
    include_executive_summary: bool = True
) -> str:
    """Generate comprehensive Markdown report.

    Args:
        results: Striking distance analysis results DataFrame
        optimization_reports: Dict of URL -> optimization report
        meta_df: Optional meta data DataFrame
        include_executive_summary: Whether to include executive summary

    Returns:
        Markdown-formatted report string
    """
    report_lines = []

    # Header
    report_lines.append("# SEO Striking Distance Analysis Report")
    report_lines.append(f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    report_lines.append("")
    report_lines.append("---")
    report_lines.append("")

    # Executive Summary
    if include_executive_summary:
        summary = generate_executive_summary(results)
        report_lines.append("## Executive Summary")
        report_lines.append("")
        report_lines.append(summary)
        report_lines.append("")
        report_lines.append("---")
        report_lines.append("")

    # Top Opportunities
    report_lines.append("## Top 20 Priority Opportunities")
    report_lines.append("")

    if 'seo_value_score' in results.columns:
        top_20 = results.nlargest(20, 'seo_value_score')
    else:
        top_20 = results.head(20)

    report_lines.append("| Rank | URL | Query | Position | Clicks | SEO Value |")
    report_lines.append("|------|-----|-------|----------|--------|-----------|")

    for idx, row in enumerate(top_20.itertuples(), 1):
        url_short = row.url[:50] + "..." if len(row.url) > 50 else row.url
        query_short = row.query[:40] + "..." if len(row.query) > 40 else row.query
        position = f"{row.position:.1f}"
        clicks = f"{int(row.clicks):,}"
        seo_value = f"{row.seo_value_score:.0f}" if hasattr(row, 'seo_value_score') else "N/A"

        report_lines.append(
            f"| {idx} | {url_short} | {query_short} | {position} | {clicks} | {seo_value} |"
        )

    report_lines.append("")
    report_lines.append("---")
    report_lines.append("")

    # Optimization Plans
    if optimization_reports:
        report_lines.append("## Detailed Optimization Plans")
        report_lines.append("")

        for url, report in optimization_reports.items():
            url_report = generate_url_optimization_markdown(url, report)
            report_lines.append(url_report)
            report_lines.append("")
            report_lines.append("---")
            report_lines.append("")

    # Keyword Analysis
    report_lines.append("## Keyword Analysis")
    report_lines.append("")
    keyword_analysis = generate_keyword_analysis_markdown(results)
    report_lines.append(keyword_analysis)
    report_lines.append("")
    report_lines.append("---")
    report_lines.append("")

    # Recommended Next Steps
    report_lines.append("## Recommended Next Steps")
    report_lines.append("")
    next_steps = generate_next_steps(results, optimization_reports)
    report_lines.append(next_steps)
    report_lines.append("")

    # Footer
    report_lines.append("---")
    report_lines.append("")
    report_lines.append("*Report generated by SEO Striking Distance Analyzer*")
    report_lines.append("")

    return "\n".join(report_lines)


def generate_executive_summary(results: pd.DataFrame) -> str:
    """Generate executive summary from results.

    Args:
        results: Analysis results DataFrame

    Returns:
        Executive summary text
    """
    total_opportunities = len(results)
    unique_urls = results['url'].nunique()

    avg_position = results['position'].mean()
    total_clicks = results['clicks'].sum()
    total_impressions = results['impressions'].sum()

    # Optimization rate
    if 'overall_optimized' in results.columns:
        optimized_count = results['overall_optimized'].sum()
        optimization_rate = (optimized_count / total_opportunities * 100) if total_opportunities > 0 else 0
    else:
        optimized_count = 0
        optimization_rate = 0

    # Priority breakdown
    if 'seo_value_score' in results.columns:
        high_priority = len(results[results['seo_value_score'] >= 75])
        medium_priority = len(results[(results['seo_value_score'] >= 50) & (results['seo_value_score'] < 75)])
        low_priority = len(results[results['seo_value_score'] < 50])
    else:
        high_priority = medium_priority = low_priority = 0

    # Search volume if available
    if 'search_volume' in results.columns:
        total_volume = results['search_volume'].sum()
        avg_volume = results['search_volume'].mean()
        volume_section = f"""
- **Total Search Volume**: {int(total_volume):,}
- **Avg. Search Volume**: {int(avg_volume):,}
"""
    else:
        volume_section = ""

    summary = f"""
### Key Metrics

- **Total Opportunities**: {total_opportunities:,} URL-query combinations
- **Unique URLs**: {unique_urls:,}
- **Average Position**: {avg_position:.1f}
- **Total Clicks**: {int(total_clicks):,}
- **Total Impressions**: {int(total_impressions):,}
- **Optimization Rate**: {optimization_rate:.1f}% ({optimized_count:,}/{total_opportunities:,} optimized)
{volume_section}

### Priority Breakdown

- **High Priority (≥75)**: {high_priority:,} opportunities
- **Medium Priority (50-74)**: {medium_priority:,} opportunities
- **Low Priority (<50)**: {low_priority:,} opportunities

### Key Insights

This analysis identified **{total_opportunities:,} striking distance opportunities** across **{unique_urls:,} pages**.
Currently, only **{optimization_rate:.1f}%** of these opportunities are properly optimized on-page, leaving
**{total_opportunities - optimized_count:,} opportunities** for improvement.

The pages analyzed are ranking in positions **{avg_position:.1f}** on average and generating **{int(total_clicks):,} clicks**
from **{int(total_impressions):,} impressions**. By optimizing the missing keywords, you can potentially improve rankings
and capture more organic traffic.
"""

    return summary


def generate_url_optimization_markdown(url: str, report: Dict[str, Any]) -> str:
    """Generate Markdown section for URL optimization plan.

    Args:
        url: Page URL
        report: Optimization report dict

    Returns:
        Markdown-formatted optimization plan
    """
    lines = []

    lines.append(f"### {url}")
    lines.append("")

    # Current Performance
    perf = report.get('current_performance', {})
    lines.append("**Current Performance:**")
    lines.append(f"- Avg Position: {perf.get('avg_position', 0):.1f}")
    lines.append(f"- Total Clicks: {int(perf.get('total_clicks', 0)):,}")
    lines.append(f"- Total Impressions: {int(perf.get('total_impressions', 0)):,}")
    lines.append("")

    # Keyword Analysis
    kw_analysis = report.get('keyword_analysis', {})
    if kw_analysis:
        lines.append("**Keyword Opportunities:**")
        lines.append(f"- Total Missing: {kw_analysis.get('total_missing', 0)}")
        lines.append(f"- Recommended: {kw_analysis.get('recommended_count', 0)} (fit naturally & match intent)")
        lines.append(f"- Filtered: {kw_analysis.get('filtered_count', 0)} (low relevancy or intent mismatch)")
        lines.append("")

        if kw_analysis.get('top_recommended'):
            lines.append("**Top Keywords to Target:**")
            for kw in kw_analysis['top_recommended']:
                lines.append(f"- `{kw}`")
            lines.append("")

    # Title Variations
    if 'title_variations' in report:
        lines.append("#### Title Optimization")
        lines.append("")
        lines.append(f"**Current:** {report['current']['title']}")
        lines.append("")
        lines.append("**Recommended Variations:**")
        lines.append("")

        for i, var in enumerate(report['title_variations'], 1):
            lines.append(f"{i}. **{var['title']}**")
            lines.append(f"   - Length: {var['length']} chars")
            lines.append(f"   - Keywords added: {', '.join(var.get('keywords_added', []))}")
            lines.append(f"   - Reasoning: {var.get('reasoning', '')}")
            lines.append("")

    # H1 Optimization
    if 'h1_suggestion' in report:
        lines.append("#### H1 Optimization")
        lines.append("")
        lines.append(f"**Current:** {report['current']['h1']}")
        lines.append(f"**Recommended:** {report['h1_suggestion']['h1']}")
        lines.append(f"- Keywords: {', '.join(report['h1_suggestion'].get('keywords_added', []))}")
        lines.append(f"- Reasoning: {report['h1_suggestion'].get('reasoning', '')}")
        lines.append("")

    # Meta Description
    if 'meta_descriptions' in report and report['meta_descriptions']:
        lines.append("#### Meta Description Optimization")
        lines.append("")
        lines.append(f"**Current:** {report['current']['meta_description']}")
        lines.append("")
        lines.append("**Recommended:**")
        lines.append("")

        for i, meta in enumerate(report['meta_descriptions'], 1):
            lines.append(f"{i}. {meta['meta_description']}")
            lines.append(f"   - Length: {meta['length']} chars")
            lines.append(f"   - Keywords: {', '.join(meta.get('keywords_added', []))}")
            lines.append("")

    # No recommendations
    if 'recommendation' in report:
        lines.append(f"**Note:** {report['recommendation']}")
        lines.append("")

    return "\n".join(lines)


def generate_keyword_analysis_markdown(results: pd.DataFrame) -> str:
    """Generate keyword analysis section.

    Args:
        results: Analysis results DataFrame

    Returns:
        Markdown-formatted keyword analysis
    """
    lines = []

    # Top keywords by SEO value
    if 'seo_value_score' in results.columns:
        lines.append("### Top Keywords by SEO Value")
        lines.append("")

        top_keywords = results.nlargest(15, 'seo_value_score')[
            ['query', 'position', 'clicks', 'impressions', 'seo_value_score']
        ]

        lines.append("| Query | Position | Clicks | Impressions | SEO Value |")
        lines.append("|-------|----------|--------|-------------|-----------|")

        for row in top_keywords.itertuples():
            query = row.query[:50] + "..." if len(row.query) > 50 else row.query
            lines.append(
                f"| {query} | {row.position:.1f} | {int(row.clicks):,} | "
                f"{int(row.impressions):,} | {row.seo_value_score:.0f} |"
            )

        lines.append("")

    # Keywords by URL
    lines.append("### Keywords per URL")
    lines.append("")

    url_keyword_counts = results.groupby('url').size().sort_values(ascending=False).head(10)

    lines.append("| URL | Keyword Count |")
    lines.append("|-----|---------------|")

    for url, count in url_keyword_counts.items():
        url_short = url[:60] + "..." if len(url) > 60 else url
        lines.append(f"| {url_short} | {count} |")

    lines.append("")

    return "\n".join(lines)


def generate_next_steps(
    results: pd.DataFrame,
    optimization_reports: Dict[str, Dict]
) -> str:
    """Generate recommended next steps.

    Args:
        results: Analysis results
        optimization_reports: Optimization reports dict

    Returns:
        Markdown-formatted next steps
    """
    lines = []

    # Prioritize
    lines.append("### 1. Prioritize High-Value Opportunities")
    lines.append("")

    if 'seo_value_score' in results.columns:
        high_priority_count = len(results[results['seo_value_score'] >= 75])
        lines.append(
            f"Focus on the **{high_priority_count}** high-priority opportunities (SEO Value ≥75) first. "
            "These have the best combination of relevancy, traffic potential, and ranking opportunity."
        )
    else:
        lines.append("Focus on keywords with the highest clicks and lowest position (closest to page 1).")

    lines.append("")

    # Implement optimizations
    lines.append("### 2. Implement On-Page Optimizations")
    lines.append("")
    lines.append("For each URL with optimization recommendations:")
    lines.append("")
    lines.append("- **Update Title Tags**: Choose the variation that best balances keywords and readability")
    lines.append("- **Optimize H1**: Ensure it incorporates the most important missing keywords")
    lines.append("- **Add H2 Sections**: Create content sections targeting keyword clusters")
    lines.append("- **Update Meta Descriptions**: Use compelling variations that include target keywords")
    lines.append("")

    # Content updates
    lines.append("### 3. Expand Content")
    lines.append("")
    lines.append("For keywords that don't currently fit:")
    lines.append("")
    lines.append("- Review filtered keywords and their intent mismatches")
    lines.append("- Consider creating new content sections or pages")
    lines.append("- Add FAQ sections to target informational queries")
    lines.append("")

    # Monitor
    lines.append("### 4. Monitor & Iterate")
    lines.append("")
    lines.append("After implementing changes:")
    lines.append("")
    lines.append("- Wait 2-4 weeks for Google to re-index")
    lines.append("- Re-run this analysis to track improvements")
    lines.append("- Monitor rankings, clicks, and impressions in GSC")
    lines.append("- Adjust optimizations based on performance data")
    lines.append("")

    # Quick wins
    if optimization_reports:
        lines.append("### 5. Quick Wins")
        lines.append("")
        lines.append("Start with these URLs (have optimization recommendations ready):")
        lines.append("")

        for idx, url in enumerate(list(optimization_reports.keys())[:5], 1):
            url_short = url[:70] + "..." if len(url) > 70 else url
            lines.append(f"{idx}. {url_short}")

        lines.append("")

    return "\n".join(lines)


def generate_csv_report(
    results: pd.DataFrame,
    include_columns: Optional[List[str]] = None
) -> str:
    """Generate CSV export.

    Args:
        results: Analysis results DataFrame
        include_columns: Optional list of columns to include

    Returns:
        CSV string
    """
    if include_columns:
        export_df = results[include_columns]
    else:
        export_df = results

    return export_df.to_csv(index=False)


def generate_html_report(
    results: pd.DataFrame,
    optimization_reports: Dict[str, Dict]
) -> str:
    """Generate HTML report (optional - for future enhancement).

    Args:
        results: Analysis results
        optimization_reports: Optimization reports

    Returns:
        HTML string
    """
    # Convert markdown to HTML (basic implementation)
    markdown_report = generate_markdown_report(results, optimization_reports)

    # Simple HTML wrapper
    html = f"""
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>SEO Striking Distance Analysis Report</title>
    <style>
        body {{
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica', 'Arial', sans-serif;
            line-height: 1.6;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            color: #333;
        }}
        h1, h2, h3 {{
            color: #2c3e50;
        }}
        table {{
            border-collapse: collapse;
            width: 100%;
            margin: 20px 0;
        }}
        th, td {{
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }}
        th {{
            background-color: #f8f9fa;
            font-weight: 600;
        }}
        code {{
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }}
        hr {{
            border: none;
            border-top: 2px solid #e1e4e8;
            margin: 30px 0;
        }}
    </style>
</head>
<body>
<pre>{markdown_report}</pre>
</body>
</html>
"""

    return html
